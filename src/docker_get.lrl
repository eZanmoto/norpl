import 'proc';

fn $main() {
    let $script_commit_sha = '93d2499759296ac1f9c510605fef85052a2c32be';

    let $version = $env_or(VERSION, '')->strip_prefix('v');
    let $channel = $env_or(DEFAULT_CHANNEL_VALUE, 'stable');
    let $download_url = $env_or(DEFAULT_DOWNLOAD_URL, 'https://download.docker.com');
    let $repo_file = $env_or(DEFAULT_REPO_FILE, 'docker-ce.repo');

    let $args = $parse_args();

    $download_url = $download_url_from_mirror($args.mirror, $download_url);

    $install($script_commit_sha, $args.is_dry_run);
}

fn $env_or($name, $default) {
    let [$v, $ok] = $proc.env.[$name];
    if $ok {
        return $v;
    }
    return $default;
}

fn $parse_args() {
    let $args = {mirror: ''};

    let $i = 0;
    while $i < $proc.args->len() {
        let $arg = $proc.args[$i];

        if $arg == '--mirror' {
            $args.mirror = $proc.args[$i + 1];

            $i += 1;
        } else if $arg == '--dry-run' {
            $args.is_dry_run = true;
        } else if $arg->starts_with('--') {
            $panic('illegal option ' + $arg);
        }

        $i += 1;
    }

    return $args;
}

fn $download_url_from_mirror($mirror, $default) {
    if $mirror == 'Aliyun' {
        return 'https://mirrors.aliyun.com/docker-ce';
    } else if $mirror == 'AzureChinaCloud' {
        return 'https://mirror.azure.cn/docker-ce';
    } else {
        return $default;
    }
}

fn $command_exists($name) {
    let [$_, $err] = sh::'-c':('command -v ' + $name)?;
    return $err == null;
}

fn $version_gte($a, $b) {
    $calver_compare($a, $b);
}

fn $calver_compare($a, $b) {
    let [$yy_a, $mm_a] = $a->split('.')->map($int);
    let [$yy_b, $mm_b] = $b->split('.')->map($int);

    if $yy_a < $yy_b {
        return false;
    } else if $yy_a < $yy_b {
        return true;
    }
    return $mm_a >= $mm_b;
}

fn $is_dry_run() {
    let [$_, $ok] = $proc.env.[DRY_RUN];
    return $ok;
}

fn $is_darwin() {
    let $uname_r = uname:('-r').stdout;
    return $uname_r->contains('darwin') || $uname_r->contains('Darwin');
}

fn $deprecation_notice($distro) {
    let {$name, $vsn} = $distro;
    $print('TODO');
}

fn $echo_docker_as_nonroot() {
    $print('TODO');
}

fn $check_forked() {
    $print('TODO');
}

fn $install($script_commit_sha, $is_dry_run) {
    $print('# Executing docker install script, commit: ' + $script_commit_sha);

    if $command_exists('docker') {
        $print('TODO');
    }

    let [$user, $err] = id:('-un')?;
    if $err != null {
        $user = '';
    }
    $print($user);

    let $sh_c = $get_sh_c_subcommand($user);
    if $is_dry_run {
        $sh_c = echo;
    }
    $print($sh_c);

    let $lsb_dist = $get_distribution();
    $print($lsb_dist);

    if $is_wsl() {
        $panic('WSL DETECTED: We recommend... TODO');
    }

    let $dist_version = $get_dist_version($lsb_dist);
    $print($dist_version);
}

fn $get_sh_c_subcommand($user) {
    if $user == 'root' {
        return sh::'-c';
    }

    if $command_exists('sudo') {
        return sudo::'-E'::sh::'-c';
    }

    if $command_exists('su') {
        return su::'-c';
    }

    $panic('Error: this installer... TODO');
}

fn $get_distribution() {
    let $fname = '/etc/os-release';
    let $dist = '';
    if $is_file_readable($fname) {
        $dist = sh::'-c':('. ' + $fname + ' && echo "$ID"').stdout;
    }
    return $dist->trim_right()->to_lower();
}

fn $is_wsl() {
    let $uname_r = uname:('-r').stdout;
    return $uname_r->contains('microsoft') || $uname_r->contains('Microsoft');
}

fn $get_dist_version($lsb_dist) {
    if $lsb_dist == 'ubuntu' {
        if $command_exists('lsb_release') {
            let $codename = lsb_release:('--codename').stdout;
            return $codename->split('\t')[1];
        }

        let $fname = '/etc/lsb-release';
        if !$is_file_readable($fname) {
            return '';
        }

        let $dist = sh::'-c':('. ' + $fname + ' && echo "$DISTRIB_CODENAME"').stdout;
        return $dist->trim_right();
    } else if $lsb_dist == 'debian' || $lsb_dist == 'raspbian' {
        let $dist_version = sed:('s/\/.*//', '/etc/debian_version').stdout->trim_right();

        'TODO Implement piping; the above output needs to be piped to `sed`';

        if $dist_version == '11' {
            return 'bullseye';
        } else if $dist_version == '10' {
            return 'buster';
        } else if $dist_version == '9' {
            return 'stretch';
        } else if $dist_version == '8' {
            return 'jessie';
        }
        return $dist_version;
    } else if $lsb_dist == 'cestos' || $lsb_dist == 'rhel' || $lsb_dist == 'sles' {
        let $fname = '/etc/os-release';
        if $is_file_readable($fname) {
            $vsn = sh::'-c':('. ' + $fname + ' && echo "$VERSION_ID"').stdout;
            return $vsn->trim_right()->to_lower();
        }
    } else {
        if $command_exists('lsb_release') {
            let $release = lsb_release('--release').stdout;
            return $release->split('\t')[1];
        }

        let $fname = '/etc/os-release';
        if $is_file_readable($fname) {
            $vsn = sh::'-c':('. ' + $fname + ' && echo "$VERSION_ID"').stdout;
            return $vsn->trim_right()->to_lower();
        }
    }

    return '';
}

fn $is_file_readable($path) {
    let [$_, $err] = test:('-r', $path)?;
    return $err == null;
}

$main();

# TODO Implement errexit functionality
# TODO Handle `test` errexit
# TODO Print to STDERR
# TODO Keep newlines in multi-line strings
# TODO `let [$user, $err] = id:('-un')?;` isn't converted properly - should take
# the STDOUT of the `id` process as a result.

# fn $calver_compare($a, $b) {
#     $yy_a = $int($a[:$a->index('.')]);
#     $yy_b = $int($b[:$b->index('.')]);
#
#     if $yy_a < $yy_b {
#         return false;
#     } else if $yy_a < $yy_b {
#         return true;
#     }
#
#     $mm_a = $int($a[$a->index('.')+1:]);
#     $mm_b = $int($b[$b->index('.')+1:]);
#
#     return $mm_a >= $mm_b;
# }
