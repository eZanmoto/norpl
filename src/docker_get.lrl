import 'proc';

fn $main() {
    let $script_commit_sha = '93d2499759296ac1f9c510605fef85052a2c32be';

    let $version = $env_or(VERSION, '')->strip_prefix('v');
    let $channel = $env_or(DEFAULT_CHANNEL_VALUE, 'stable');
    let $download_url = $env_or(DEFAULT_DOWNLOAD_URL, 'https://download.docker.com');
    let $repo_file = $env_or(DEFAULT_REPO_FILE, 'docker-ce.repo');

    let $args = $parse_args();

    $download_url = $download_url_from_mirror($args.mirror, $download_url);

    $install($script_commit_sha, $args.is_dry_run);
}

fn $env_or($name, $default) {
    let [$v, $ok] = $proc.env[$name]?;
    if $ok {
        return $v;
    }
    return $default;
}

fn $parse_args() {
    let $args = {mirror: ''};

    let $i = 0;
    while $i < $proc.args->len() {
        let $arg = $proc.args[$i];

        if $arg == '--mirror' {
            $args.mirror = $proc.args[$i + 1];

            $i += 1;
        } else if $arg == '--dry-run' {
            $args.is_dry_run = true;
        } else if $arg->starts_with('--') {
            $panic('illegal option ' + $arg);
        }

        $i += 1;
    }

    return $args;
}

fn $download_url_from_mirror($mirror, $default) {
    if $mirror == 'Aliyun' {
        return 'https://mirrors.aliyun.com/docker-ce';
    } else if $mirror == 'AzureChinaCloud' {
        return 'https://mirror.azure.cn/docker-ce';
    } else {
        return $default;
    }
}

fn $command_exists($name) {
    let [$_, $ok] = sh::'-c':($'command -v {$name}')?;
    return $ok;
}

fn $version_gte($a, $b) {
    $calver_compare($a, $b);
}

fn $calver_compare($a, $b) {
    let [$yy_a, $mm_a] = $a->split('.')->map($int);
    let [$yy_b, $mm_b] = $b->split('.')->map($int);

    if $yy_a < $yy_b {
        return false;
    } else if $yy_a < $yy_b {
        return true;
    }
    return $mm_a >= $mm_b;
}

fn $is_dry_run() {
    let [$_, $ok] = $proc.env[DRY_RUN]?;
    return $ok;
}

fn $is_darwin() {
    let $uname_r = uname:('-r').stdout;
    return $uname_r->contains('darwin') || $uname_r->contains('Darwin');
}

fn $deprecation_notice($distro, $distro_vsn) {
    $print('DEPRECATION WARNING {$distro} {$distro_version}');

    sleep:('10');
}

fn $echo_docker_as_nonroot() {
    $print('TODO');
}

fn $check_forked($lsb_dist, $dist_version) {
    if !$command_exists('lsb_release') {
        return null;
    }

    let [$lr, $ok] = lsb_release:('-a', '-u')?;
    if !$ok {
        $print($lr.stderr);
        $proc.exit();
    }

    if $lr.exit_code == 0 {
        $print('You"re using "{$lsb_dist}" version "{$dist_version}".');

        let $lsb_dist = $lr.stdout->to_lower();
        let $dist_version = $lr.stdout->to_lower();
        # TODO Implement piping; the above output needs to be piped to `grep`.

        $print('Upstream release is "{$lsb_dist}" version "{$dist_version}".');

        return {lsb_dist, dist_version};
    }

    if
        !$is_file_readable('/etc/debian_version')
        || $lsb_dist == 'ubuntu'
        || $lsb_dist == 'raspbian'
    {
        return null;
    }

    if $lsb_dist == 'osmc' {
        $lsb_dist = 'raspbian';
    } else {
        $lsb_dist = 'debian';
    }

    return {
        lsb_dist,
        dist_version: $get_debian_version(),
    };
}

fn $install($script_commit_sha, $is_dry_run) {
    $print($'# Executing docker install script, commit: {$script_commit_sha}');

    if $command_exists('docker') {
        $print('TODO');
    }

    let [$user, $ok] = id:('-un')?;
    if !$ok {
        $user = '';
    }
    $print($user);

    let $sh_c = $get_sh_c_subcommand($user);
    if $is_dry_run {
        $sh_c = echo;
    }
    $print($sh_c);

    let $lsb_dist = $get_distribution();
    $print($lsb_dist);

    if $is_wsl() {
        $panic('WSL DETECTED: We recommend... TODO');
    }

    let $dist_version = $get_dist_version($lsb_dist);
    $print($dist_version);

    let $forked_version = $check_forked($lsb_dist, $dist_version);
    if $forked_version != null {
        {lsb_dist, dist_version} = $forked_version;
    }

    let $dist_pair = $'{$lsb_dist}.{$dist_version}';
    if
        $dist_pair == 'debian.stretch' || $dist_pair == 'debian.jessie'
        || $dist_pair == 'raspbian.stretch' || $dist_pair == 'raspbian.jessie'
        || $dist_pair == 'ubuntu.xenial' || $dist_pair == 'ubuntu.trusty'
        # TODO Add support for short-circuit evaluation, so that when `fedora`
        # isn't matched, we don't attempt to compare a string to an integer.
        # TODO Add support for parsing integers from strings.
        # || ($lsb_dist == 'fedora' && $dist_version < 33)
    {
        $deprecation_notice($lsb_dist, dist_version);
    }
}

fn $get_sh_c_subcommand($user) {
    if $user == 'root' {
        return sh::'-c';
    }

    if $command_exists('sudo') {
        return sudo::'-E'::sh::'-c';
    }

    if $command_exists('su') {
        return su::'-c';
    }

    $panic('Error: this installer... TODO');
}

fn $get_distribution() {
    let $fname = '/etc/os-release';
    let $dist = '';
    if $is_file_readable($fname) {
        $dist = sh::'-c':($'. {$fname} && echo "$ID"').stdout;
    }
    return $dist->trim_right()->to_lower();
}

fn $is_wsl() {
    let $uname_r = uname:('-r').stdout;
    return $uname_r->contains('microsoft') || $uname_r->contains('Microsoft');
}

fn $get_dist_version($lsb_dist) {
    if $lsb_dist == 'ubuntu' {
        if $command_exists('lsb_release') {
            let $codename = lsb_release:('--codename').stdout;
            return $codename->split('\t')[1];
        }

        let $fname = '/etc/lsb-release';
        if !$is_file_readable($fname) {
            return '';
        }

        let $dist = sh::'-c':($'. {$fname} && echo "$DISTRIB_CODENAME"').stdout;
        return $dist->trim_right();
    } else if $lsb_dist == 'debian' || $lsb_dist == 'raspbian' {
        return $get_debian_version();
    } else if $lsb_dist == 'cestos' || $lsb_dist == 'rhel' || $lsb_dist == 'sles' {
        let $fname = '/etc/os-release';
        if $is_file_readable($fname) {
            $vsn = sh::'-c':($'. {$fname} && echo "$VERSION_ID"').stdout;
            return $vsn->trim_right()->to_lower();
        }
    } else {
        if $command_exists('lsb_release') {
            let $release = lsb_release('--release').stdout;
            return $release->split('\t')[1];
        }

        let $fname = '/etc/os-release';
        if $is_file_readable($fname) {
            $vsn = sh::'-c':($'. {$fname} && echo "$VERSION_ID"').stdout;
            return $vsn->trim_right()->to_lower();
        }
    }

    return '';
}

fn $get_debian_version() {
    let $dist_version = sed:('s/\/.*//', '/etc/debian_version').stdout->trim_right();

    # TODO Implement piping; the above output needs to be piped to `sed`.

    if $dist_version == '11' {
        return 'bullseye';
    } else if $dist_version == '10' {
        return 'buster';
    } else if $dist_version == '9' {
        return 'stretch';
    } else if $dist_version == '8' {
        return 'jessie';
    }
    return $dist_version;
}

fn $is_file_readable($path) {
    let [$_, $ok] = test:('-r', $path)?;
    return $ok;
}

$main();

# TODO Implement errexit functionality
# TODO Handle `test` errexit
# TODO Print to STDERR
# TODO Keep newlines in multi-line strings
# TODO `let [$user, $err] = id:('-un')?;` isn't converted properly - should take
# the STDOUT of the `id` process as a result.

# fn $calver_compare($a, $b) {
#     $yy_a = $int($a[:$a->index('.')]);
#     $yy_b = $int($b[:$b->index('.')]);
#
#     if $yy_a < $yy_b {
#         return false;
#     } else if $yy_a < $yy_b {
#         return true;
#     }
#
#     $mm_a = $int($a[$a->index('.')+1:]);
#     $mm_b = $int($b[$b->index('.')+1:]);
#
#     return $mm_a >= $mm_b;
# }
