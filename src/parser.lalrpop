// Copyright 2021 Sean Kelleher. All rights reserved.
// Use of this source code is governed by an MIT
// licence that can be found in the LICENCE file.

use ast::*;

grammar;

pub Prog: Prog = {
    <stmts:Stmt*> => Prog::Body{stmts},
}

pub Stmt: Stmt = {
    <expr:Expr> ";" => Stmt::Expr{expr},

    "let" <lhs:Expr> "=" <rhs:Expr> ";" => Stmt::Declare{lhs, rhs},
    <lhs:Expr> "=" <rhs:Expr> ";" => Stmt::Assign{lhs, rhs},

    <name:Ident> "+=" <rhs:Expr> ";" => Stmt::OpAssign{name, op: BinaryOp::Sum, rhs},
    <name:Ident> "-=" <rhs:Expr> ";" => Stmt::OpAssign{name, op: BinaryOp::Sub, rhs},
    <name:Ident> "*=" <rhs:Expr> ";" => Stmt::OpAssign{name, op: BinaryOp::Mul, rhs},
    <name:Ident> "/=" <rhs:Expr> ";" => Stmt::OpAssign{name, op: BinaryOp::Div, rhs},

    <stmt:IfStmt> => stmt,
    "while" <cond:Expr> <stmts:Block> => Stmt::While{cond, stmts},
    "for" <lhs:Expr> "in" <iter:Expr> <stmts:Block> => Stmt::For{lhs, iter, stmts},

    "fn" <name:Ident> "(" <args:ArgNames> ")" <stmts:Block> => Stmt::Func{name, args, stmts},
    "return" <expr:Expr> ";" => Stmt::Return{expr},
}

pub ArgNames: Vec<String> = {
    () => vec![],
    <head:Ident> => vec![head],
    <head:Ident> "," <tail:ArgNames> => {
        let mut list = tail.clone();
        list.insert(0, head);

        list
    },
}

pub Block: Vec<Stmt> = {
    "{" <stmts:Stmt*> "}" => stmts,
}

pub IfStmt: Stmt = {
    "if" <cond:Expr> <if_stmts:Block> =>
        Stmt::If{cond, if_stmts, else_stmts: None},
    "if" <cond:Expr> <if_stmts:Block> "else" <else_stmts:Block> =>
        Stmt::If{cond, if_stmts, else_stmts: Some(else_stmts)},
}

pub Expr: Expr = {
    <lhs:Expr> "==" <rhs:Factor> => Expr::BinaryOp{op: BinaryOp::EQ, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:Expr> "!=" <rhs:Factor> => Expr::BinaryOp{op: BinaryOp::NE, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:Expr> ">" <rhs:Factor> => Expr::BinaryOp{op: BinaryOp::GT, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:Expr> "<" <rhs:Factor> => Expr::BinaryOp{op: BinaryOp::LT, lhs: Box::new(lhs), rhs: Box::new(rhs)},

    <lhs:Expr> "&&" <rhs:Factor> => Expr::BinaryOp{op: BinaryOp::And, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:Expr> "||" <rhs:Factor> => Expr::BinaryOp{op: BinaryOp::Or, lhs: Box::new(lhs), rhs: Box::new(rhs)},

    <start:Expr> ".." <end:Factor> =>
        Expr::Range{start: Box::new(start), end: Box::new(end)},

    <expr:Expr> "[" <location:Expr> "]" =>
        Expr::Index{expr: Box::new(expr), location: Box::new(location)},

    <expr:Term> => expr,
}

pub Term: Expr = {
    <lhs:Term> "+" <rhs:Factor> => Expr::BinaryOp{op: BinaryOp::Sum, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:Term> "-" <rhs:Factor> => Expr::BinaryOp{op: BinaryOp::Sub, lhs: Box::new(lhs), rhs: Box::new(rhs)},

    <expr:Factor> => expr,
}

pub Factor: Expr = {
    "!" <expr:Expr_> => Expr::UnaryOp{op: UnaryOp::Not, expr: Box::new(expr)},

    <lhs:Factor> "*" <rhs:Expr_> => Expr::BinaryOp{op: BinaryOp::Mul, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:Factor> "/" <rhs:Expr_> => Expr::BinaryOp{op: BinaryOp::Div, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:Factor> "%" <rhs:Expr_> => Expr::BinaryOp{op: BinaryOp::Mod, lhs: Box::new(lhs), rhs: Box::new(rhs)},

    <expr:Expr_> => expr,
}

pub Expr_: Expr = {
    "null" => Expr::Null,
    "true" => Expr::Bool{b: true},
    "false" => Expr::Bool{b: false},

    <name:Ident> => Expr::Var{name},
    <n:IntLiteral> => Expr::Int{n},
    <s:StrLiteral> => Expr::Str{s},

    <func:Ident> "(" <args:ParamList> ")" => Expr::Call{func, args: args},

    "[" <xs:ExprList> "]" => Expr::List{xs},

    "{" <props:PropList> "}" => Expr::Object{props},

    "(" <expr:Expr> ")" => expr,

    "fn" "(" <args:ArgNames> ")" <stmts:Block> => Expr::Func{args, stmts},
}

pub ParamList: Vec<Expr> = {
    () => vec![],
    <head:Expr> => vec![head],
    <head:Expr> "," <tail:ParamList> => {
        let mut list = tail.clone();
        list.insert(0, head);

        list
    },
}

pub ExprList: Vec<ListItem> = {
    () => vec![],
    <unspread:".."?> <head:Expr> <spread:".."?> => vec![ListItem{
        expr: head,
        is_spread: spread.is_some(),
        is_unspread: unspread.is_some(),
    }],
    <head:Expr> <spread:".."?> "," <tail:ExprList> => {
        let mut list = tail.clone();
        let head_ = ListItem{
            expr: head,
            is_spread: spread.is_some(),
            is_unspread: false,
        };
        list.insert(0, head_);

        list
    },
}

pub PropList: Vec<PropItem> = {
    () => vec![],
    <head:PropItem> => vec![head],
    <head:PropItem> "," <tail:PropList> => {
        let mut list = tail.clone();
        list.insert(0, head);

        list
    },
}

pub PropItem: PropItem = {
    <name:StrLiteral> ":" <value:Expr> =>
        PropItem::Pair{name, value},
    <unspread:".."?> <expr:Expr> <spread:".."?> =>
        PropItem::Single{
            expr,
            is_spread: spread.is_some(),
            is_unspread: unspread.is_some(),
        },
}

Ident: String = {
    <s:r"[_a-zA-Z][_a-zA-Z0-9]*"> => s.to_string(),
};

StrLiteral: String = {
    <s:r"'[^']*'"> => s.trim_matches('\'').to_string(),
};

IntLiteral: i64 = {
    <s:r"[0-9]+"> => s.parse().unwrap(),
};

match {
    r"\s*" => {},
    r"#[^\n\r]*[\n\r]*" => {},
    _,
}
