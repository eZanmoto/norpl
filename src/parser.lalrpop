// Copyright 2021-2022 Sean Kelleher. All rights reserved.
// Use of this source code is governed by an MIT
// licence that can be found in the LICENCE file.

use ast::*;
use lexer::LexError;
use lexer::Location as LexLocation;
use lexer::Token;

grammar;

pub Prog: Prog = {
    <stmts:Stmt*> => Prog::Body{stmts},
}

pub Stmt: Stmt = {
    <expr:Expr> ";" => Stmt::Expr{expr},

    "import" <name:QuotedStrLiteral> ";" => Stmt::Import{name},

    <lhs:Expr> "$:=" <rhs:Expr> ";" => Stmt::Declare{lhs, rhs, dt: DeclarationType::Var},
    <lhs:Expr> ":=" <rhs:Expr> ";" => Stmt::Declare{lhs, rhs, dt: DeclarationType::Const},
    <lhs:Expr> "=" <rhs:Expr> ";" => Stmt::Assign{lhs, rhs},

    <lhs:Expr> "+=" <rhs:Expr> ";" => Stmt::OpAssign{lhs, op: BinaryOp::Sum, rhs},
    <lhs:Expr> "-=" <rhs:Expr> ";" => Stmt::OpAssign{lhs, op: BinaryOp::Sub, rhs},
    <lhs:Expr> "*=" <rhs:Expr> ";" => Stmt::OpAssign{lhs, op: BinaryOp::Mul, rhs},
    <lhs:Expr> "/=" <rhs:Expr> ";" => Stmt::OpAssign{lhs, op: BinaryOp::Div, rhs},

    <stmt:IfStmt> => {
        let (branches, else_stmts) = stmt;

        Stmt::If{branches, else_stmts}
    },
    "while" <cond:Expr> <stmts:Block> => Stmt::While{cond, stmts},
    "for" <lhs:Expr> "in" <iter:Expr> <stmts:Block> => Stmt::For{lhs, iter, stmts},

    "fn" <name:Ident> "(" <args:ParamList> ")" <stmts:Block> => Stmt::Func{name, args, stmts},
    "return" <expr:Expr> ";" => Stmt::Return{expr},
}

pub ArgNames: Vec<String> = {
    () => vec![],
    <head:Ident> => vec![head],
    <head:Ident> "," <tail:ArgNames> => {
        let mut list = tail.clone();
        list.insert(0, head);

        list
    },
}

pub Block: Block = {
    "{" <stmts:Stmt*> "}" => stmts,
}

pub IfStmt: (Vec<Branch>, Option<Block>) = {
    "if" <cond:Expr> <if_stmts:Block> => {
        (vec![Branch{cond, stmts: if_stmts}], None)
    },

    "if" <cond:Expr> <if_stmts:Block> "else" <else_stmts:Block> => {
        (vec![Branch{cond, stmts: if_stmts}], Some(else_stmts))
    },

    "if" <cond:Expr> <if_stmts:Block> "else" <if_else_stmts:IfStmt> => {
        let (mut branches, else_stmts) = if_else_stmts;
        branches.insert(0, Branch{cond, stmts: if_stmts});

        (branches, else_stmts)
    },
}

pub Expr: Expr = {
    <expr:ExprPrecedence1> => expr,
}

// `ExprPrecedence1` defines the most loosely binding expressions. Each
// increasing precedence indicates a tighter binding.
pub ExprPrecedence1: Expr = {
    <lhs:Expr> "&&" <rhs:ExprPrecedence2> => Expr::BinaryOp{op: BinaryOp::And, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:Expr> "||" <rhs:ExprPrecedence2> => Expr::BinaryOp{op: BinaryOp::Or, lhs: Box::new(lhs), rhs: Box::new(rhs)},

    <start:Expr> ".." <end:ExprPrecedence2> =>
        Expr::Range{start: Box::new(start), end: Box::new(end)},

    <expr:Expr> "?" => Expr::CatchAsBool{expr: Box::new(expr)},
    <expr:Expr> "??" => Expr::CatchAsError{expr: Box::new(expr)},

    <expr:ExprPrecedence2> => expr,
}

pub ExprPrecedence2: Expr = {
    <lhs:ExprPrecedence2> "+" <rhs:ExprPrecedence3> => Expr::BinaryOp{op: BinaryOp::Sum, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:ExprPrecedence2> "-" <rhs:ExprPrecedence3> => Expr::BinaryOp{op: BinaryOp::Sub, lhs: Box::new(lhs), rhs: Box::new(rhs)},

    <expr:ExprPrecedence3> => expr,
}

pub ExprPrecedence3: Expr = {
    "!" <expr:ExprPrecedence4> => Expr::UnaryOp{op: UnaryOp::Not, expr: Box::new(expr)},

    <lhs:ExprPrecedence3> "*" <rhs:ExprPrecedence4> => Expr::BinaryOp{op: BinaryOp::Mul, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:ExprPrecedence3> "/" <rhs:ExprPrecedence4> => Expr::BinaryOp{op: BinaryOp::Div, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:ExprPrecedence3> "%" <rhs:ExprPrecedence4> => Expr::BinaryOp{op: BinaryOp::Mod, lhs: Box::new(lhs), rhs: Box::new(rhs)},

    <lhs:ExprPrecedence3> "==" <rhs:ExprPrecedence4> => Expr::BinaryOp{op: BinaryOp::EQ, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:ExprPrecedence3> "!=" <rhs:ExprPrecedence4> => Expr::BinaryOp{op: BinaryOp::NE, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:ExprPrecedence3> ">" <rhs:ExprPrecedence4> => Expr::BinaryOp{op: BinaryOp::GT, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:ExprPrecedence3> ">=" <rhs:ExprPrecedence4> => Expr::BinaryOp{op: BinaryOp::GTE, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:ExprPrecedence3> "<" <rhs:ExprPrecedence4> => Expr::BinaryOp{op: BinaryOp::LT, lhs: Box::new(lhs), rhs: Box::new(rhs)},
    <lhs:ExprPrecedence3> "<=" <rhs:ExprPrecedence4> => Expr::BinaryOp{op: BinaryOp::LTE, lhs: Box::new(lhs), rhs: Box::new(rhs)},

    <expr:ExprPrecedence4> => expr,
}

pub ExprPrecedence4: Expr = {
    <expr:ExprPrecedence4> "(" <args:ParamList> ")" =>
        Expr::Call{expr: Box::new(expr), args: args},

    <expr:ExprPrecedence4> ":(" <args:ParamList> ")" =>
        Expr::Spawn{expr: Box::new(expr), args: args},

    <expr:ExprPrecedence4> "[" <location:Expr> "]" =>
        Expr::Index{expr: Box::new(expr), location: Box::new(location)},

    <expr:ExprPrecedence4> "[" <start:Expr?> ":" <end:Expr?> "]" =>
        Expr::IndexRange{
            expr: Box::new(expr),
            start: start.map(|v| Box::new(v)),
            end: end.map(|v| Box::new(v)),
        },

    <expr:ExprPrecedence4> "." <name:UnquotedStrLiteral> =>
        Expr::Prop{expr: Box::new(expr), name, prototype: false},

    <expr:ExprPrecedence4> "->" <name:UnquotedStrLiteral> =>
        Expr::Prop{expr: Box::new(expr), name, prototype: true},

    <expr:ExprPrecedence4> "::" <name:StrLiteral> =>
        Expr::Subcommand{expr: Box::new(expr), name},

    <expr:ExprPrecedence5> => expr,
}

pub ExprPrecedence5: Expr = {
    "null" => Expr::Null,
    "true" => Expr::Bool{b: true},
    "false" => Expr::Bool{b: false},

    <name:Ident> => Expr::Var{name},
    <n:IntLiteral> => Expr::Int{n},
    <s:StrLiteral> => Expr::Str{s},
    <s:InterpolatedStrLiteral> => Expr::InterpolatedStr{s},

    "[" <xs:ExprList> "]" => Expr::List{xs, is_mutable: false},
    "$[" <xs:ExprList> "]" => Expr::List{xs, is_mutable: true},

    "{" <props:PropList> "}" => Expr::Object{props, is_mutable: false},
    "${" <props:PropList> "}" => Expr::Object{props, is_mutable: true},

    "(" <expr:Expr> ")" => expr,

    "fn" "(" <args:ParamList> ")" <stmts:Block> => Expr::Func{args, stmts},
}

pub ParamList: Vec<Expr> = {
    () => vec![],
    <head:Expr> => vec![head],
    <head:Expr> "," <tail:ParamList> => {
        let mut list = tail.clone();
        list.insert(0, head);

        list
    },
}

pub ExprList: Vec<ListItem> = {
    () => vec![],
    <unspread:".."?> <head:Expr> <spread:".."?> => vec![ListItem{
        expr: head,
        is_spread: spread.is_some(),
        is_unspread: unspread.is_some(),
    }],
    <head:Expr> <spread:".."?> "," <tail:ExprList> => {
        let mut list = tail.clone();
        let head_ = ListItem{
            expr: head,
            is_spread: spread.is_some(),
            is_unspread: false,
        };
        list.insert(0, head_);

        list
    },
}

pub PropList: Vec<PropItem> = {
    () => vec![],
    <head:PropItem> => vec![head],
    <head:PropItem> "," <tail:PropList> => {
        let mut list = tail.clone();
        list.insert(0, head);

        list
    },
}

pub PropItem: PropItem = {
    <name:Expr> ":" <value:Expr> =>
        PropItem::Pair{name, value},
    <unspread:".."?> <expr:Expr> <spread:".."?> =>
        PropItem::Single{
            expr,
            is_spread: spread.is_some(),
            is_unspread: unspread.is_some(),
        },
}

Ident: String = {
    <s:"ident"> => s,
};

StrLiteral: String = {
    <s:QuotedStrLiteral> => s,
    <s:UnquotedStrLiteral> => s,
};

InterpolatedStrLiteral: String = {
    <s:"interpolated_str_literal"> => s,
}

QuotedStrLiteral: String = {
    <s:"quoted_str_literal"> => s,
}

UnquotedStrLiteral: String = {
    <s:"unquoted_str_literal"> => s,
}

IntLiteral: i64 = {
    <n:"int_literal"> => n,
};

extern {
    type Location = LexLocation;
    type Error = LexError;

    enum Token {
        "ident" => Token::Ident(<String>),
        "int_literal" => Token::IntLiteral(<i64>),
        "interpolated_str_literal" => Token::InterpolatedStrLiteral(<String>),
        "quoted_str_literal" => Token::QuotedStrLiteral(<String>),
        "unquoted_str_literal" => Token::UnquotedStrLiteral(<String>),

        "else" => Token::Else,
        "false" => Token::False,
        "fn" => Token::Fn,
        "for" => Token::For,
        "if" => Token::If,
        "import" => Token::Import,
        "in" => Token::In,
        "null" => Token::Null,
        "return" => Token::Return,
        "true" => Token::True,
        "while" => Token::While,

        ":" => Token::Bang,
        "!" => Token::Bang,
        "}" => Token::BraceClose,
        "{" => Token::BraceOpen,
        "]" => Token::BracketClose,
        "[" => Token::BracketOpen,
        ":" => Token::Colon,
        "," => Token::Comma,
        "/" => Token::Div,
        "." => Token::Dot,
        "=" => Token::Equals,
        "%" => Token::Mod,
        "*" => Token::Mul,
        ")" => Token::ParenClose,
        "(" => Token::ParenOpen,
        "?" => Token::QuestionMark,
        ";" => Token::Semicolon,
        "-" => Token::Sub,
        "+" => Token::Sum,

        "&&" => Token::AndAnd,
        "!=" => Token::BangEquals,
        "::" => Token::ColonColon,
        ":=" => Token::ColonEquals,
        ":(" => Token::ColonParenOpen,
        "->" => Token::DashGreaterThan,
        "/=" => Token::DivEquals,
        "${" => Token::DollarBrace,
        "$[" => Token::DollarBracket,
        ".." => Token::DotDot,
        "==" => Token::EqualsEquals,
        ">" => Token::GreaterThan,
        ">=" => Token::GreaterThanEquals,
        "<" => Token::LessThan,
        "<=" => Token::LessThanEquals,
        "*=" => Token::MulEquals,
        "||" => Token::OrOr,
        "??" => Token::QuestionQuestion,
        "-=" => Token::SubEquals,
        "+=" => Token::SumEquals,

        "$:=" => Token::DollarColonEquals,
    }
}
